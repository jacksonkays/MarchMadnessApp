// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { __asyncDelegator, __asyncGenerator, __asyncValues, __await, __rest } from "tslib";
import "@azure/core-paging";
import { isNamedKeyCredential, isSASCredential, isTokenCredential, } from "@azure/core-auth";
import { STORAGE_SCOPE, TablesLoggingAllowedHeaderNames } from "./utils/constants";
import { parseXML, stringifyXML } from "@azure/core-xml";
import { GeneratedClient } from "./generated/generatedClient";
import { SpanStatusCode } from "@azure/core-tracing";
import { createSpan } from "./utils/tracing";
import { getClientParamsFromConnectionString } from "./utils/connectionString";
import { handleTableAlreadyExists } from "./utils/errorHelpers";
import { isCredential } from "./utils/isCredential";
import { logger } from "./logger";
import { tablesNamedKeyCredentialPolicy } from "./tablesNamedCredentialPolicy";
import { tablesSASTokenPolicy } from "./tablesSASTokenPolicy";
/**
 * A TableServiceClient represents a Client to the Azure Tables service allowing you
 * to perform operations on the tables and the entities.
 */
export class TableServiceClient {
    constructor(url, credentialOrOptions, options) {
        this.url = url;
        const credential = isCredential(credentialOrOptions) ? credentialOrOptions : undefined;
        const clientOptions = (!isCredential(credentialOrOptions) ? credentialOrOptions : options) || {};
        clientOptions.endpoint = clientOptions.endpoint || this.url;
        const internalPipelineOptions = Object.assign(Object.assign(Object.assign({}, clientOptions), {
            loggingOptions: {
                logger: logger.info,
                additionalAllowedHeaderNames: [...TablesLoggingAllowedHeaderNames],
            },
            deserializationOptions: {
                parseXML,
            },
            serializationOptions: {
                stringifyXML,
            },
        }), (isTokenCredential(credential) && { credential, credentialScopes: STORAGE_SCOPE }));
        const client = new GeneratedClient(this.url, internalPipelineOptions);
        if (isNamedKeyCredential(credential)) {
            client.pipeline.addPolicy(tablesNamedKeyCredentialPolicy(credential));
        }
        else if (isSASCredential(credential)) {
            client.pipeline.addPolicy(tablesSASTokenPolicy(credential));
        }
        this.pipeline = client.pipeline;
        this.table = client.table;
        this.service = client.service;
    }
    /**
     * Retrieves statistics related to replication for the Table service. It is only available on the
     * secondary location endpoint when read-access geo-redundant replication is enabled for the account.
     * @param options - The options parameters.
     */
    async getStatistics(options = {}) {
        const { span, updatedOptions } = createSpan("TableServiceClient-getStatistics", options);
        try {
            return await this.service.getStatistics(updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Gets the properties of an account's Table service, including properties for Analytics and CORS
     * (Cross-Origin Resource Sharing) rules.
     * @param options - The options parameters.
     */
    async getProperties(options = {}) {
        const { span, updatedOptions } = createSpan("TableServiceClient-getProperties", options);
        try {
            return await this.service.getProperties(updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Sets properties for an account's Table service endpoint, including properties for Analytics and CORS
     * (Cross-Origin Resource Sharing) rules.
     * @param properties - The Table Service properties.
     * @param options - The options parameters.
     */
    async setProperties(properties, options = {}) {
        const { span, updatedOptions } = createSpan("TableServiceClient-setProperties", options);
        try {
            return await this.service.setProperties(properties, updatedOptions);
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Creates a new table under the given account.
     * @param name - The name of the table.
     * @param options - The options parameters.
     */
    async createTable(name, options = {}) {
        const { span, updatedOptions } = createSpan("TableServiceClient-createTable", options);
        try {
            await this.table.create({ name }, Object.assign({}, updatedOptions));
        }
        catch (e) {
            handleTableAlreadyExists(e, Object.assign(Object.assign({}, updatedOptions), { span, logger, tableName: name }));
        }
        finally {
            span.end();
        }
    }
    /**
     * Operation permanently deletes the specified table.
     * @param name - The name of the table.
     * @param options - The options parameters.
     */
    async deleteTable(name, options = {}) {
        const { span, updatedOptions } = createSpan("TableServiceClient-deleteTable", options);
        try {
            await this.table.delete(name, updatedOptions);
        }
        catch (e) {
            if (e.statusCode === 404) {
                logger.info("TableServiceClient-deleteTable: Table doesn't exist");
            }
            else {
                span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
                throw e;
            }
        }
        finally {
            span.end();
        }
    }
    /**
     * Queries tables under the given account.
     * @param options - The options parameters.
     */
    listTables(
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        const iter = this.listTablesAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: (settings) => {
                const pageOptions = Object.assign(Object.assign({}, options), { queryOptions: { top: settings === null || settings === void 0 ? void 0 : settings.maxPageSize } });
                if (settings === null || settings === void 0 ? void 0 : settings.continuationToken) {
                    pageOptions.continuationToken = settings.continuationToken;
                }
                return this.listTablesPage(pageOptions);
            },
        };
    }
    listTablesAll(options) {
        return __asyncGenerator(this, arguments, function* listTablesAll_1() {
            var e_1, _a;
            const firstPage = yield __await(this._listTables(options));
            const { continuationToken } = firstPage;
            yield __await(yield* __asyncDelegator(__asyncValues(firstPage)));
            if (continuationToken) {
                const optionsWithContinuation = Object.assign(Object.assign({}, options), { continuationToken });
                try {
                    for (var _b = __asyncValues(this.listTablesPage(optionsWithContinuation)), _c; _c = yield __await(_b.next()), !_c.done;) {
                        const page = _c.value;
                        yield __await(yield* __asyncDelegator(__asyncValues(page)));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield __await(_a.call(_b));
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
        });
    }
    listTablesPage(options = {}) {
        return __asyncGenerator(this, arguments, function* listTablesPage_1() {
            const { span, updatedOptions } = createSpan("TableServiceClient-listTablesPage", options);
            try {
                let result = yield __await(this._listTables(updatedOptions));
                yield yield __await(result);
                while (result.continuationToken) {
                    const optionsWithContinuation = Object.assign(Object.assign({}, updatedOptions), { continuationToken: result.continuationToken });
                    result = yield __await(this._listTables(optionsWithContinuation));
                    yield yield __await(result);
                }
            }
            catch (e) {
                span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
                throw e;
            }
            finally {
                span.end();
            }
        });
    }
    async _listTables(options = {}) {
        const { continuationToken: nextTableName } = options, listOptions = __rest(options, ["continuationToken"]);
        const { xMsContinuationNextTableName: continuationToken, value = [] } = await this.table.query(Object.assign(Object.assign({}, listOptions), { nextTableName }));
        return Object.assign([...value], { continuationToken });
    }
    /**
     *
     * Creates an instance of TableServiceClient from connection string.
     *
     * @param connectionString - Account connection string or a SAS connection string of an Azure storage account.
     *                           [ Note - Account connection string can only be used in NODE.JS runtime. ]
     *                           Account connection string example -
     *                           `DefaultEndpointsProtocol=https;AccountName=myaccount;AccountKey=accountKey;EndpointSuffix=core.windows.net`
     *                           SAS connection string example -
     *                           `BlobEndpoint=https://myaccount.table.core.windows.net/;QueueEndpoint=https://myaccount.queue.core.windows.net/;FileEndpoint=https://myaccount.file.core.windows.net/;TableEndpoint=https://myaccount.table.core.windows.net/;SharedAccessSignature=sasString`
     * @param options - Options to configure the HTTP pipeline.
     * @returns A new TableServiceClient from the given connection string.
     */
    static fromConnectionString(connectionString, 
    // eslint-disable-next-line @azure/azure-sdk/ts-naming-options
    options) {
        const { url, options: clientOptions, credential, } = getClientParamsFromConnectionString(connectionString, options);
        if (credential) {
            return new TableServiceClient(url, credential, clientOptions);
        }
        else {
            return new TableServiceClient(url, clientOptions);
        }
    }
}
//# sourceMappingURL=TableServiceClient.js.map